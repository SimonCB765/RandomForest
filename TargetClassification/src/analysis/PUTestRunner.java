package analysis;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;

import tree.PUForest;
import tree.PUProcessDataForGrowing;
import tree.PUTreeGrowthControl;

public class PUTestRunner
{
	/**
	 * The aggregated confusion matrix produced by summing up all the predictions in this.confusionMatrices.
	 */
	private Map<String, Map<String, Double>> aggregateConfusionMatrix = new HashMap<String, Map<String, Double>>();

	/**
	 * The confusion matrices generated by the test. There is one confusion matrix in the list for each repetition.
	 */
	private List<Map<String, Map<String, Double>>> confusionMatrices = new ArrayList<Map<String, Map<String, Double>>>();

	/**
	 * The number of repetitions of training and testing that are performed in this test. For cross-validation this is the number of separate
	 * sets of folds that were generated (e.g. 20 sets of 10 fold cross-validation means that numberOfRepetitions==20).
	 */
	private int numberOfRepetitions;

	/**
	 * The total time taken to train all the forests for the test. Equal to the sum of the time taken over all repetitions.
	 */
	private long timeTaken;

	/**
	 * The location of a dataset tested on the trained forests, but not used in the training of the forests.
	 */
	private String testDataset;

	/**
	 * The location of the original dataset used to train the forests. In the case of cross-validation, this should be the dataset that the folds
	 * were generated from.
	 */
	private String trainingDataset;
	

	/**
	 * @return - The confusion matrix produced by aggregating the confusion matrices for all the test repetitions.
	 */
	public Map<String, Map<String, Double>> getAggregateConfMat()
	{
		return this.aggregateConfusionMatrix;
	}

	/**
	 * @return - The list of the confusion matrices generated by the test.
	 */
	public List<Map<String, Map<String, Double>>> getConfusionMatrices()
	{
		return this.confusionMatrices;
	}

	/**
	 * @return - The total time taken to train all the forests for the test.
	 */
	public long getTimeTaken()
	{
		return this.timeTaken;
	}


	/**
	 * Calculate the statistics from the aggregated confusion matrices generated by the test.
	 * 
	 * @return - A map containing the names of the statistics calculated along with their values.
	 */
	public Map<String, Double> calculateAggregateStats()
	{
		// Aggregate the confusion matrices.
		for (String s : this.confusionMatrices.get(0).keySet())
		{
			this.aggregateConfusionMatrix.put(s, new HashMap<String, Double>());
			this.aggregateConfusionMatrix.get(s).put("TruePositive", 0.0);
			this.aggregateConfusionMatrix.get(s).put("FalsePositive", 0.0);
		}
		for (Map<String, Map<String, Double>> cf : this.confusionMatrices)
		{
			for (String s : cf.keySet())
			{
    			Double oldTruePos = this.aggregateConfusionMatrix.get(s).get("TruePositive");
    			Double newTruePos = oldTruePos + cf.get(s).get("TruePositive");
    			this.aggregateConfusionMatrix.get(s).put("TruePositive", newTruePos);
    			Double oldFalsePos = this.aggregateConfusionMatrix.get(s).get("FalsePositive");
    			Double newFalsePos = oldFalsePos + cf.get(s).get("FalsePositive");
    			this.aggregateConfusionMatrix.get(s).put("FalsePositive", newFalsePos);
			}
		}

		// Process the input dataset, and determine the number of observations from each class in the dataset.
		PUProcessDataForGrowing processedInputFile = new PUProcessDataForGrowing(this.trainingDataset, new PUTreeGrowthControl());
		Map<String, Integer> countsOfClass = new HashMap<String, Integer>();
		for (String s : new HashSet<String>(processedInputFile.responseData))
		{
			countsOfClass.put(s, Collections.frequency(processedInputFile.responseData, s));
		}

		// Process the test set dataset (if one was supplied), and add the counts of the classes in the test set to the counts in the input dataset.
		if (this.testDataset != null)
		{
			PUProcessDataForGrowing processedTestSet = new PUProcessDataForGrowing(this.testDataset, new PUTreeGrowthControl());
			for (String s : countsOfClass.keySet())
			{
				Integer trainingSetCounts = countsOfClass.get(s);
				countsOfClass.put(s, Collections.frequency(processedTestSet.responseData, s) + trainingSetCounts);
			}
		}

		double totalPredictions = 0.0;  // The total number of predictions made.
		double incorrectPredictions = 0.0;  // The total number of incorrect predictions made.
		// Macro rather than micro calculations are used in order to handle datasets with imbalanced classes.
		double macroRecall = 0.0;
		double macroPrecision = 0.0;
		double macroGMean = 1.0;
		double MCC = 0.0;
		for (String s : this.aggregateConfusionMatrix.keySet())
		{
			double TP = this.aggregateConfusionMatrix.get(s).get("TruePositive");  // Observations of this class predicted as this class.
			double FP = this.aggregateConfusionMatrix.get(s).get("FalsePositive");  // Observations from other classes predicted as this class.
			// For binary classification the false negatives are easy to determine. However, for multi-class problems the false negatives must be
			// calculated as the difference between the number of predictions of observations in a class and the number of true positives for the class.
			// In this case the number of predictions of the observations in a class is the number of observations in the class multiplied by the number
			// of forest created (as each observation is predicted once per forest). This assumes that the number of trees in the forest is sufficient
			// for each observation to be oob on a sufficient number of trees (not an issue for cross-validation).
    		double FN = (this.numberOfRepetitions * countsOfClass.get(s)) - TP;  // Observations of this class predicted as other classes.
    		double recall = (TP / (TP + FN));
    		macroRecall += recall;
    		double precision = (TP / (TP + FP));
    		macroPrecision += precision;
    		macroGMean *= recall;
    		totalPredictions += TP + FP;
    		incorrectPredictions += FP;
		}
		if (this.aggregateConfusionMatrix.size() == 2)
		{
			// If there are only two classes, then calculate the MCC. Will handle classes of any name.
			List<Double> correctPredictionsMCC = new ArrayList<Double>();
			List<Double> incorrectPredictionsMCC = new ArrayList<Double>();
			for (String s : this.aggregateConfusionMatrix.keySet())
			{
				correctPredictionsMCC.add(this.aggregateConfusionMatrix.get(s).get("TruePositive"));
				incorrectPredictionsMCC.add(this.aggregateConfusionMatrix.get(s).get("FalsePositive"));
			}
			// It doesn't matter which class is 'positive' and which 'negative' in the MCC calculation.
			double TP = correctPredictionsMCC.get(0);
			double FP = incorrectPredictionsMCC.get(0);
			double TN = correctPredictionsMCC.get(1);
			double FN = incorrectPredictionsMCC.get(1);
			MCC = ((TP * TN) - (FP * FN)) / (Math.sqrt((TP + TN) * (TP + FN) * (TN + FP) * (TN + FN)));
		}
		macroRecall /= this.aggregateConfusionMatrix.size();
		macroPrecision /= this.aggregateConfusionMatrix.size();
		double fHalf = (1 + (0.5 * 0.5)) * ((macroPrecision * macroRecall) / ((0.5 * 0.5 * macroPrecision) + macroRecall));
		double fOne = 2 * ((macroPrecision * macroRecall) / (macroPrecision + macroRecall));
		double fTwo = (1 + (2 * 2)) * ((macroPrecision * macroRecall) / ((2 * 2 * macroPrecision) + macroRecall));
		double gMean = Math.pow(macroGMean, (1.0 / this.aggregateConfusionMatrix.size()));
		double errorRate = incorrectPredictions / totalPredictions;

		// Generate the return map.
		Map<String, Double> statistics = new HashMap<String, Double>();
		statistics.put("MCC", MCC);
		statistics.put("F0.5", fHalf);
		statistics.put("F1", fOne);
		statistics.put("F2", fTwo);
		statistics.put("GMean", gMean);
		statistics.put("ErrorRate", errorRate);
		return statistics;
	}

	/**
	 * Calculate the statistics for each confusion matrix generated by the test.
	 * 
	 * @return - A map containing the names of the statistics calculated along with their values for each repetition.
	 */
	public Map<String, List<Double>> calculateStats()
	{
		// Process the input dataset, and determine the number of observations from each class in the dataset.
		PUProcessDataForGrowing processedInputFile = new PUProcessDataForGrowing(this.trainingDataset, new PUTreeGrowthControl());
		Map<String, Integer> countsOfClass = new HashMap<String, Integer>();
		for (String s : new HashSet<String>(processedInputFile.responseData))
		{
			countsOfClass.put(s, Collections.frequency(processedInputFile.responseData, s));
		}

		// Process the test set dataset (if one was supplied), and add the counts of the classes in the test set to the counts in the input dataset.
		if (this.testDataset != null)
		{
			PUProcessDataForGrowing processedTestSet = new PUProcessDataForGrowing(this.testDataset, new PUTreeGrowthControl());
			for (String s : countsOfClass.keySet())
			{
				Integer trainingSetCounts = countsOfClass.get(s);
				countsOfClass.put(s, Collections.frequency(processedTestSet.responseData, s) + trainingSetCounts);
			}
		}

		List<Double> errorRates = new ArrayList<Double>();
		List<Double> gMeans = new ArrayList<Double>();
		List<Double> mccs = new ArrayList<Double>();
		List<Double> fHalves = new ArrayList<Double>();
		List<Double> fOnes = new ArrayList<Double>();
		List<Double> fTwos = new ArrayList<Double>();

		for (Map<String, Map<String, Double>> cf : this.confusionMatrices)
		{
			double totalPredictions = 0.0;  // The total number of predictions made.
			double incorrectPredictions = 0.0;  // The total number of incorrect predictions made.
			// Macro rather than micro calculations are used in order to handle datasets with imbalanced classes.
			double macroRecall = 0.0;
			double macroPrecision = 0.0;
			double macroGMean = 1.0;
			double MCC = 0.0;
			for (String s : cf.keySet())
			{
				double TP = cf.get(s).get("TruePositive");  // Observations of this class predicted as this class.
				double FP = cf.get(s).get("FalsePositive");  // Observations from other classes predicted as this class.
				// For binary classification the false negatives are easy to determine. However, for multi-class problems the false negatives must be
				// calculated as the difference between the number of predictions of observations in a class and the number of true positives for the class.
				// This assumes that the number of trees in the forest is sufficient for each observation to be oob on a sufficient number of
				// trees (not an issue for cross-validation).
	    		double FN = countsOfClass.get(s) - TP;  // Observations of this class predicted as other classes.
	    		double recall = (TP / (TP + FN));
	    		macroRecall += recall;
	    		double precision = (TP / (TP + FP));
	    		macroPrecision += precision;
	    		macroGMean *= recall;
	    		totalPredictions += TP + FP;
	    		incorrectPredictions += FP;
			}
			if (cf.size() == 2)
			{
				// If there are only two classes, then calculate the MCC. Will handle classes of any name.
				List<Double> correctPredictionsMCC = new ArrayList<Double>();
				List<Double> incorrectPredictionsMCC = new ArrayList<Double>();
				for (String s : cf.keySet())
				{
					correctPredictionsMCC.add(cf.get(s).get("TruePositive"));
					incorrectPredictionsMCC.add(cf.get(s).get("FalsePositive"));
				}
				// It doesn't matter which class is 'positive' and which 'negative' in the MCC calculation.
				double TP = correctPredictionsMCC.get(0);
				double FP = incorrectPredictionsMCC.get(0);
				double TN = correctPredictionsMCC.get(1);
				double FN = incorrectPredictionsMCC.get(1);
				MCC = ((TP * TN) - (FP * FN)) / (Math.sqrt((TP + TN) * (TP + FN) * (TN + FP) * (TN + FN)));
			}
			macroRecall /= cf.size();
			macroPrecision /= cf.size();
			double fHalf = (1 + (0.5 * 0.5)) * ((macroPrecision * macroRecall) / ((0.5 * 0.5 * macroPrecision) + macroRecall));
			double fOne = 2 * ((macroPrecision * macroRecall) / (macroPrecision + macroRecall));
			double fTwo = (1 + (2 * 2)) * ((macroPrecision * macroRecall) / ((2 * 2 * macroPrecision) + macroRecall));
			double gMean = Math.pow(macroGMean, (1.0 / cf.size()));
			double errorRate = incorrectPredictions / totalPredictions;

			// Add the stats for this repetition to the lists.
			errorRates.add(errorRate);
			gMeans.add(gMean);
			mccs.add(MCC);
			fHalves.add(fHalf);
			fOnes.add(fOne);
			fTwos.add(fTwo);
		}

		// Generate the return map.
		Map<String, List<Double>> statistics = new HashMap<String, List<Double>>();
		statistics.put("MCC", mccs);
		statistics.put("F0.5", fHalves);
		statistics.put("F1", fOnes);
		statistics.put("F2", fTwos);
		statistics.put("GMean", gMeans);
		statistics.put("ErrorRate", errorRates);
		return statistics;
	}

	/**
	 * Calculate the confusion matrices for a given set of parameters.
	 * 
	 * Generates numberOfForestsToCreate forests, and records the confusion matrices.
	 * 
	 * @param weights - The mapping of the weights for each class in the input dataset.
	 * @param ctrl - The control object used to parse the input dataset and grow the forests.
	 * @param inputFile - The location of the input dataset.
	 * @param seeds - The seeds that will be used to grow the forests (one for every forest being grown).
	 * @param numberOfForestsToCreate - The number of forests to create.
	 * @param testFileLocation - The location of the test dataset (or null if there isn't one).
	 * @param discounts - The mapping from "Positive" to the positive discounts for the observations, and "Unlabelled" to the unlabelled discounts.
	 */
	public void generateForests(Map<String, Double> weights, PUTreeGrowthControl ctrl, String inputFile, List<Long> seeds, int numberOfForestsToCreate,
			String testFileLocation, Map<String, Map<Integer, Double>> discounts)
	{
		// Record the input parameters needed in the calculation of the statistics.
		this.trainingDataset = inputFile;
		this.testDataset = testFileLocation;
		this.numberOfRepetitions = numberOfForestsToCreate;

		// Setup the timing variables.
		Date startTime;
		Date endTime;

		// Process the input dataset (and test dataset if there is one).
		PUProcessDataForGrowing processedInputFile = new PUProcessDataForGrowing(this.trainingDataset, ctrl);
		PUProcessDataForGrowing processedTestFile = null;
		if (this.testDataset != null)
		{
			processedTestFile = new PUProcessDataForGrowing(this.testDataset, new PUTreeGrowthControl());
		}

		// Generate each forest, and determine the additions to make to the confusion matrix.
		for (int i = 0; i < this.numberOfRepetitions; i++)
		{
			// Get the seed for this repetition.
			long seed = seeds.get(i);

			// Create the confusion matrices for this repetition.
			Map<String, Map<String, Double>> confusionMatrix = new HashMap<String, Map<String, Double>>();
			for (String s : weights.keySet())
			{
				confusionMatrix.put(s, new HashMap<String, Double>());
				confusionMatrix.get(s).put("TruePositive", 0.0);
				confusionMatrix.get(s).put("FalsePositive", 0.0);
			}

			startTime = new Date();
			PUForest forest = new PUForest(processedInputFile, ctrl, seed);
			forest.setClassWeights(weights);
			forest.setPositiveDiscounts(discounts.get("Positive"));
			forest.setUnlabelledDiscounts(discounts.get("Unlabelled"));
			forest.growForest();
			for (String s : forest.oobConfusionMatrix.keySet())
    		{
    			Double oldTruePos = confusionMatrix.get(s).get("TruePositive");
    			Double newTruePos = oldTruePos + forest.oobConfusionMatrix.get(s).get("TruePositive");
    			confusionMatrix.get(s).put("TruePositive", newTruePos);
    			Double oldFalsePos = confusionMatrix.get(s).get("FalsePositive");
    			Double newFalsePos = oldFalsePos + forest.oobConfusionMatrix.get(s).get("FalsePositive");
    			confusionMatrix.get(s).put("FalsePositive", newFalsePos);
    		}

			// Generate the test set predictions.
			if (this.testDataset != null)
			{
				Map<String, Map<String, Double>> predResults = forest.predict(processedTestFile).second;
				for (String s : predResults.keySet())
	    		{
					Double oldTruePos = confusionMatrix.get(s).get("TruePositive");
	    			Double newTruePos = oldTruePos + predResults.get(s).get("TruePositive");
	    			confusionMatrix.get(s).put("TruePositive", newTruePos);
	    			Double oldFalsePos = confusionMatrix.get(s).get("FalsePositive");
	    			Double newFalsePos = oldFalsePos + predResults.get(s).get("FalsePositive");
	    			confusionMatrix.get(s).put("FalsePositive", newFalsePos);
	    		}
			}

			// Update the timing.
			endTime = new Date();
			this.timeTaken += endTime.getTime() - startTime.getTime();

			// Add the confusion matrix for this repetition to the list.
			this.confusionMatrices.add(confusionMatrix);
		}
	}

}

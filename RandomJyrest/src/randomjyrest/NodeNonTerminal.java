package randomjyrest;

import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * Implements a non-terminal node.
 */
public class NodeNonTerminal extends Node
{

	// The attributes of a non-terminal node in a tree.
	Node[] children = new Node[2];  // The child nodes of this node.
	double splitValue;  // The value of the feature that is used to split the node.
	String featureSplitOn;  // The feature that is used to split the node.


	/**
	 * Class constructor for a non-terminal node.
	 * 
	 * @param featureSplitOn	The feature that is used to split the node.
	 * @param splitValue		The value of the feature that is used to split the node.
	 * @param leftChild			The left child of the node.
	 * @param rightChild		The right child of the node.
	 */
	public NodeNonTerminal(String featureSplitOn, double splitValue, Node leftChild, Node rightChild)
	{
		this.splitValue = splitValue;
		this.children[0] = leftChild;
		this.children[1] = rightChild;
		this.featureSplitOn = featureSplitOn;
	}
	
	/**
	 * Generate the predictions for all observations that reach this node in the tree.
	 * 
	 * The predictions Map is initialised to contain an empty array for each class, and then passed down the tree in a depth first
	 * manner and filled up. Once the prediction generation is finished, there will be a prediction for each observation.
	 * 
	 * @param datasetToPredict	The data for every observation in the entire set of data that is to be predicted (not just the data
	 * 							for the observations that have reached this node).
	 * @param obsToPredict		The indices of the observations that have reached this node.
	 * @param predictions		The predictions of the observations in the entire dataset.
	 * @return					The predictions of the observations in the entire dataset that were passed in with the predictions of
	 * 							the observations that reached this node (generated by the subtree rooted at this node) added to it.
	 */
	public final Map<String, double[]> predict(Map<String, double[]> datasetToPredict, Set<Integer> obsToPredict,
			Map<String, double[]> predictions)
	{
		double[] dataForSplitFeature = datasetToPredict.get(this.featureSplitOn);  // Get the values of the feature the node was split on
																				   // for every observation that is to be predicted.

		Set<Integer> leftChildObs = new HashSet<Integer>();  // The indices of the observations that should be predicted by the left child.
		Set<Integer> rightChildObs = new HashSet<Integer>();  // The indices of the observations that should be predicted by the right child.
		for (Integer i : obsToPredict)
		{
			if (dataForSplitFeature[i] <= this.splitValue)
			{
				// Observation should be predicted by the left child.
				leftChildObs.add(i);
			}
			else
			{
				// Observation should be predicted by the right child.
				rightChildObs.add(i);
			}
		}
		
		// Have the child nodes make predictions, and aggregate them into the record of the final predictions.
		predictions = this.children[0].predict(datasetToPredict, leftChildObs, predictions);
		predictions = this.children[1].predict(datasetToPredict, rightChildObs, predictions);
		
		return predictions;
	}

}
